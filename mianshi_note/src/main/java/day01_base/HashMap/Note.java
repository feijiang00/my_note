package day01_base.HashMap;

import java.util.HashMap;
import java.util.Map;

/**
 * @date 2021/12/15 9:26
 */
public class Note {
    /**
     * 1.7jdk底层是数组+链表
     * 1.8之后，底层则是数组+（链表或者红黑树）
     * 为什么hashmap查找效率这么高？
     * 它添加一个对象的时候，会计算其hashmap，然后对map容量取余,之后存储到其对应的数组下标下的链表中，当下次查找时，计算其hashcode就能轻松找到
     *
     * hashmap的扩容机制？
     * hashmap初始容量为16，加载因子为0.75，扩容增量是原来的一倍。比如原容量是16，那么当其中存储的元素个数大于12的时候，就会扩容
     *
     * 二次hash的好处？hashmap中为什么数组的长度为2的幂次方？
     * 减少hash碰撞，尽量使hash算法的结果均匀分布
     * 计算索引效率更高，可以直接用位运算代替取模,并且容量大了，使分布更加均匀
     *
     * 为什么要用红黑树，为什么一上来不树化，树化阈值为何是8，何时会树化，何时会退化为链表?
     * 解决链表过长，访问速度太慢的问题；因为链表很短的时候没有必要，访问速度已经很快了，
     * hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，
     * 树化阈值选择 8 就是为了让树化几率足够小，事实上也正是如此，如果不是刻意构造hashcode，基本不会遇到树化
     * 当链表的长度大于8，并且数组的长度大于64的时候，则会树化
     * 退化：在扩容的时候会拆分树，当树节点小于6的时候则会退化
     *      remove 树节点时，若 root、root.left、root.right、root.left.left 有一个为 null ，也会退化为链表
     *
     *
     * put流程：
     *      hashmap是懒惰创建数组，首次使用才创建数组
     *      计算索引（桶下标）
     *      如果桶下标还没人占用，创建Node占位返回
     *      如果桶下标已经被占用：是treenode，则走红黑树的添加或更新逻辑
     *                         是node链表，则走链表的添加或更新，如果添加后长度超过树化阈值，走树化
     *      返回前检查容量是否超过阈值，一旦超过进行扩容
     *
     *      不同：
     *          链表插入结点时，1.7是头插法；1.8是尾插法
     *          1.7是大于等于阈值且没有空位的时候才会扩容，1.8是大于阈值就会扩容
     *          1.8在扩容计算node索引的时候，会优化：扩容时，hash & oldCap == 0的元素保留在原地，否则新位置 = 旧位置 + oldCap
     *
     *  多线程下，操作hashmap的可能错误：
     *      数据丢失：首先明白hashmap放元素流程，hashmap会先根据hashcode找到桶下标对应的链表，当插入两个hashcode一样的元素比如a和1，
     *               这时会再去比较他们的值用equals。如果，线程a找到了桶下标对应的链表发现为空，正准备插入，这时线程b运行抢先一步进行插入，那么接着
     *               线程a就会继续插入，覆盖线程b的数据的值，这叫数据丢失
     *       并发死链：因为1.7在扩容的时候，如果扩容后的两个node还是同一个桶下标，那么迁移就有可能出现并发死链。首先讲下迁移的过程，例如 a -》b结点
     *                迁移的时候，有两个游标指向头结点和下一个结点，然后将头结点移到新容器，头结点指向的就是next的结点，最后遍历将下一个结点插入新容器，这样就会造成新容器是b-》a的
     *                这种方式。当两个线程，线程a的e指向a，next指向b；刚准备迁移的时候，就被线程b迁移完了，此时是b-》a的这种情况，这时线程a继续迁移，
     *                将a插入到新容器，此时next指向的地址还是b，按迁移规则，a此时要指向next，因此变成a-》b-》a；这时就是a和b相互指向了
     *
     *
     *
     */

    public static void main(String[] args) {

        Map map = new HashMap();
        map.put(1,"a");
        map.put(2,"b");
        for (Object o : map.keySet()) {
            System.out.println(map.get(o));
        }

    }
}
